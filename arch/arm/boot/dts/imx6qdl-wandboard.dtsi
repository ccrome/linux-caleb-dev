/*
 * Copyright 2013 Freescale Semiconductor, Inc.
 *
 * Author: Fabio Estevam <fabio.estevam@freescale.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *
 */

/*
 * All pin definitions are in file
 *     arch/arm/boot/dts/imx6dl-pinfunc.h
 */

#include <dt-bindings/gpio/gpio.h>
#include <dt-bindings/sound/fsl-imx-audmux.h>
 
/ {
	regulators {
		compatible = "simple-bus";
		#address-cells = <1>;
		#size-cells = <0>;

		reg_2p5v: regulator@0 {
			compatible = "regulator-fixed";
			reg = <0>;
			regulator-name = "2P5V";
			regulator-min-microvolt = <2500000>;
			regulator-max-microvolt = <2500000>;
			regulator-always-on;
		};

		reg_3p3v: regulator@1 {
			compatible = "regulator-fixed";
			reg = <1>;
			regulator-name = "3P3V";
			regulator-min-microvolt = <3300000>;
			regulator-max-microvolt = <3300000>;
			regulator-always-on;
		};
	};

};

// #define SSI_TEST_MASTER
/*
 * port 4 is datasheet port 5 (aud5)
 * port 6 is datasheet port 7 (ssi3)
 */
#define AUDMUX_EXT_PORT 4
#define AUDMUX_INT_PORT 6
#define AUDMUX_INT_PORT_NAME port5
&audmux {
        status = "okay";
	ssi3 {
         fsl,audmux-port = <AUDMUX_INT_PORT>;
         fsl,port-config = <
#ifdef SSI_TEST_MASTER
	IMX_AUDMUX_V2_PTCR_SYN	
#else
	(IMX_AUDMUX_V2_PTCR_TFSDIR |
	IMX_AUDMUX_V2_PTCR_TFSEL(AUDMUX_EXT_PORT) |
	IMX_AUDMUX_V2_PTCR_TCLKDIR |
	IMX_AUDMUX_V2_PTCR_TCSEL(AUDMUX_EXT_PORT) |
	IMX_AUDMUX_V2_PTCR_SYN	
	)
#endif
             IMX_AUDMUX_V2_PDCR_RXDSEL(AUDMUX_EXT_PORT)
	>;
     };

     AUDMUX_INT_PORT_NAME {
         fsl,audmux-port = <AUDMUX_EXT_PORT>;
         fsl,port-config = <
#ifdef SSI_TEST_MASTER
             (IMX_AUDMUX_V2_PTCR_TFSDIR |
             IMX_AUDMUX_V2_PTCR_TFSEL(AUDMUX_INT_PORT) |
             IMX_AUDMUX_V2_PTCR_TCLKDIR |
             IMX_AUDMUX_V2_PTCR_TCSEL(AUDMUX_INT_PORT) |
	     	IMX_AUDMUX_V2_PTCR_SYN	
	     )
#else
	IMX_AUDMUX_V2_PTCR_SYN	
#endif
             IMX_AUDMUX_V2_PDCR_RXDSEL(AUDMUX_INT_PORT)
         >;
     };
};

&ssi3 {
     pinctrl-names = "default";
     pinctrl-0 = <&pinctrl_audmux>;
     status = "okay";

     // select the a clock parent suitable for 48000 Hz sampling rate
     assigned-clocks = <&clks IMX6QDL_CLK_SSI3_SEL>, <&clks IMX6QDL_CLK_SSI3>;
     assigned-clock-parents = <&clks IMX6QDL_CLK_PLL4_AUDIO_DIV>;
     assigned-clock-rates = <0>, <49152000>;
     fsl,fifo-watermark = <4>;
     fsl,dma-maxburst = <4>;
};


/ {
  sound@2 {
	  compatible = "se,chessmen";
  	  audio-codec = <&aic_a &aic_b &aic_c &aic_d>;
	  model = "chessmen-board";
	  ssi-controller = <&ssi3>;
	  audio-routing =
		"MIC_IN", "Mic Jack",
		"Mic Jack", "Mic Bias",
		"Headphone Jack", "HP_OUT";
     };
};

&i2c1 {
	clock-frequency = <100000>;
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_i2c1>;
	status = "okay";
	aic_a: aic3x1@18 {
	       #sound-dai-cells = <0>;
	       compatible = "ti,tlv320aic3x";
	       reg = <0x18>;
	       gpio-reset = <&gpio3 27 0>;
	       status="okay";
	       IOVDD-supply = <&reg_3p3v>;
	       AVDD-supply = <&reg_3p3v>;
	       DRVDD-supply = <&reg_3p3v>;
	       DVDD-supply = <&reg_3p3v>;
	};
	aic_b: aic3x1@19 {
	       #sound-dai-cells = <0>;
	       compatible = "ti,tlv320aic3x";
	       reg = <0x19>;
	       gpio-reset = <&gpio3 27 0>;
	       status="okay";
	       IOVDD-supply = <&reg_3p3v>;
	       AVDD-supply = <&reg_3p3v>;
	       DRVDD-supply = <&reg_3p3v>;
	       DVDD-supply = <&reg_3p3v>;
	};
	aic_c: aic3x1@1a {
	       #sound-dai-cells = <0>;
	       compatible = "ti,tlv320aic3x";
	       reg = <0x1a>;
	       gpio-reset = <&gpio3 27 0>;
	       status="okay";
	       IOVDD-supply = <&reg_3p3v>;
	       AVDD-supply = <&reg_3p3v>;
	       DRVDD-supply = <&reg_3p3v>;
	       DVDD-supply = <&reg_3p3v>;
	};
	aic_d: aic3x1@1b {
	       #sound-dai-cells = <0>;
	       compatible = "ti,tlv320aic3x";
	       reg = <0x1b>;
	       gpio-reset = <&gpio3 27 0>;
	       status="okay";
	       IOVDD-supply = <&reg_3p3v>;
	       AVDD-supply = <&reg_3p3v>;
	       DRVDD-supply = <&reg_3p3v>;
	       DVDD-supply = <&reg_3p3v>;
	};

};

&i2c2 {
	clock-frequency = <100000>;
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_i2c2>;
	status = "okay";

	// Keeping this sgtl5000 around so that the clock starts.
	// not sure why it won't start with clocks= in the aic_a thingy.
	codec: sgtl5000@0a {
		compatible = "fsl,sgtl5000";
		reg = <0x0a>;
		clocks = <&clks 201>;
		VDDA-supply = <&reg_2p5v>;
		VDDIO-supply = <&reg_3p3v>;
	};
};

//&i2c3 {
//	clock-frequency = <100000>;
//	pinctrl-names = "default";
//	pinctrl-0 = <&pinctrl_i2c3>;
//	status = "okay";
//};

&iomuxc {
	pinctrl-names = "default";

	imx6qdl-wandboard {

		pinctrl_audmux: audmuxgrp {
			fsl,pins = <
				// 0x130b0 = PAD_CTL_SRE_SLOW,  PAD_CTL_DSE_40ohm, PAD_CTL_SPEED_MED, PAD_CTL_PKE, PAD_CTL_PUE, PAD_CTL_PUS_22K_UP PAD_CTL_HYS
				// 0x110b0 = PAD_CTL_SRE_SLOW,  PAD_CTL_DSE_40ohm, PAD_CTL_SPEED_MED, PAD_CTL_PKE,              PAD_CTL_PUS_22K_UP PAD_CTL_HYS
				MX6QDL_PAD_CSI0_DAT7__AUD3_RXD		0x130b0
				MX6QDL_PAD_CSI0_DAT4__AUD3_TXC		0x130b0
				MX6QDL_PAD_CSI0_DAT5__AUD3_TXD		0x110b0
				MX6QDL_PAD_CSI0_DAT6__AUD3_TXFS		0x130b0
				MX6QDL_PAD_DISP0_DAT23__AUD4_RXD        0x130b0 // wandboard  jp2.10
				MX6QDL_PAD_DISP0_DAT20__AUD4_TXC	0x130b0 // wandboard  jp2.4
				MX6QDL_PAD_DISP0_DAT21__AUD4_TXD	0x110b0 // wandboard  jp2.6
				MX6QDL_PAD_DISP0_DAT22__AUD4_TXFS	0x130b0 // wandboard  jp2.8
				MX6QDL_PAD_DISP0_DAT19__AUD5_RXD        0x130b0 // wandboard  jp1.20
				MX6QDL_PAD_DISP0_DAT16__AUD5_TXC	0x130b0 // wandboard, jp1.14
				MX6QDL_PAD_DISP0_DAT17__AUD5_TXD	0x110b0 // wandboard  jp1.16
				MX6QDL_PAD_DISP0_DAT18__AUD5_TXFS	0x130b0 // wandboard  jp1.18
				MX6QDL_PAD_GPIO_19__CCM_CLKO1           0x13018 // wandboard  jp4.18
				MX6QDL_PAD_EIM_D27__GPIO3_IO27          0x130b0 // wandboard  jp4.4 codec reset pin
			>;
		};

		pinctrl_enet: enetgrp {
			fsl,pins = <
				MX6QDL_PAD_ENET_MDIO__ENET_MDIO		0x1b0b0
				MX6QDL_PAD_ENET_MDC__ENET_MDC		0x1b0b0
				MX6QDL_PAD_RGMII_TXC__RGMII_TXC		0x1b0b0
				MX6QDL_PAD_RGMII_TD0__RGMII_TD0		0x1b0b0
				MX6QDL_PAD_RGMII_TD1__RGMII_TD1		0x1b0b0
				MX6QDL_PAD_RGMII_TD2__RGMII_TD2		0x1b0b0
				MX6QDL_PAD_RGMII_TD3__RGMII_TD3		0x1b0b0
				MX6QDL_PAD_RGMII_TX_CTL__RGMII_TX_CTL	0x1b0b0
				MX6QDL_PAD_ENET_REF_CLK__ENET_TX_CLK	0x1b0b0
				MX6QDL_PAD_RGMII_RXC__RGMII_RXC		0x1b0b0
				MX6QDL_PAD_RGMII_RD0__RGMII_RD0		0x1b0b0
				MX6QDL_PAD_RGMII_RD1__RGMII_RD1		0x1b0b0
				MX6QDL_PAD_RGMII_RD2__RGMII_RD2		0x1b0b0
				MX6QDL_PAD_RGMII_RD3__RGMII_RD3		0x1b0b0
				MX6QDL_PAD_RGMII_RX_CTL__RGMII_RX_CTL	0x1b0b0
				MX6QDL_PAD_GPIO_16__ENET_REF_CLK	0x4001b0a8
				MX6QDL_PAD_GPIO_6__ENET_IRQ		0x000b1
			>;
		};

		pinctrl_i2c1: i2c1grp {
			fsl,pins = <
				MX6QDL_PAD_EIM_D21__I2C1_SCL 		0x4001b8b1
				MX6QDL_PAD_EIM_D28__I2C1_SDA 		0x4001b8b1
			>;
		};

		pinctrl_i2c2: i2c2grp {
			fsl,pins = <
				MX6QDL_PAD_KEY_COL3__I2C2_SCL		0x4001b8b1
				MX6QDL_PAD_KEY_ROW3__I2C2_SDA		0x4001b8b1
			>;
		};

//		pinctrl_i2c3: i2c3grp {
//			fsl,pins = <
//				MX6QDL_PAD_GPIO_5__I2C3_SCL		0x4001b8b1
//				MX6QDL_PAD_GPIO_16__I2C3_SDA		0x4001b8b1
//			>;
//		};

		pinctrl_spdif: spdifgrp {
			fsl,pins = <
				MX6QDL_PAD_ENET_RXD0__SPDIF_OUT		0x1b0b0
			>;
		};

		pinctrl_uart1: uart1grp {
			fsl,pins = <
				MX6QDL_PAD_CSI0_DAT10__UART1_TX_DATA	0x1b0b1
				MX6QDL_PAD_CSI0_DAT11__UART1_RX_DATA	0x1b0b1
			>;
		};

		pinctrl_uart3: uart3grp {
			fsl,pins = <
				MX6QDL_PAD_EIM_D24__UART3_TX_DATA	0x1b0b1
				MX6QDL_PAD_EIM_D25__UART3_RX_DATA	0x1b0b1
				MX6QDL_PAD_EIM_D23__UART3_CTS_B		0x1b0b1
				MX6QDL_PAD_EIM_EB3__UART3_RTS_B		0x1b0b1
			>;
		};

		pinctrl_usbotg: usbotggrp {
			fsl,pins = <
				MX6QDL_PAD_GPIO_1__USB_OTG_ID		0x17059
			>;
		};

		pinctrl_usdhc1: usdhc1grp {
			fsl,pins = <
				MX6QDL_PAD_SD1_CMD__SD1_CMD		0x17059
				MX6QDL_PAD_SD1_CLK__SD1_CLK		0x10059
				MX6QDL_PAD_SD1_DAT0__SD1_DATA0		0x17059
				MX6QDL_PAD_SD1_DAT1__SD1_DATA1		0x17059
				MX6QDL_PAD_SD1_DAT2__SD1_DATA2		0x17059
				MX6QDL_PAD_SD1_DAT3__SD1_DATA3		0x17059
			>;
		};

		pinctrl_usdhc2: usdhc2grp {
			fsl,pins = <
				MX6QDL_PAD_SD2_CMD__SD2_CMD		0x17059
				MX6QDL_PAD_SD2_CLK__SD2_CLK		0x10059
				MX6QDL_PAD_SD2_DAT0__SD2_DATA0		0x17059
				MX6QDL_PAD_SD2_DAT1__SD2_DATA1		0x17059
				MX6QDL_PAD_SD2_DAT2__SD2_DATA2		0x17059
				MX6QDL_PAD_SD2_DAT3__SD2_DATA3		0x17059
			>;
		};

		pinctrl_usdhc3: usdhc3grp {
			fsl,pins = <
				MX6QDL_PAD_SD3_CMD__SD3_CMD		0x17059
				MX6QDL_PAD_SD3_CLK__SD3_CLK		0x10059
				MX6QDL_PAD_SD3_DAT0__SD3_DATA0		0x17059
				MX6QDL_PAD_SD3_DAT1__SD3_DATA1		0x17059
				MX6QDL_PAD_SD3_DAT2__SD3_DATA2		0x17059
				MX6QDL_PAD_SD3_DAT3__SD3_DATA3		0x17059
			>;
		};
	};
};

&fec {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_enet>;
	phy-mode = "rgmii";
	phy-reset-gpios = <&gpio3 29 0>;
	interrupts-extended = <&gpio1 6 IRQ_TYPE_LEVEL_HIGH>,
			      <&intc 0 119 IRQ_TYPE_LEVEL_HIGH>;
	status = "okay";
};

&spdif {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_spdif>;
	status = "okay";
};

&uart1 {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_uart1>;
	status = "okay";
};

&uart3 {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_uart3>;
	fsl,uart-has-rtscts;
	status = "okay";
};

&usbh1 {
	status = "okay";
};

&usbotg {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_usbotg>;
	disable-over-current;
	dr_mode = "peripheral";
	status = "okay";
};

&usdhc1 {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_usdhc1>;
	cd-gpios = <&gpio1 2 GPIO_ACTIVE_LOW>;
	status = "okay";
};

&usdhc3 {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_usdhc3>;
	cd-gpios = <&gpio3 9 GPIO_ACTIVE_LOW>;
	status = "okay";
};
